/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"math"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/snyk/snyk-ls/domain/snyk"
	"github.com/snyk/snyk-ls/internal/testutil"
)

const testFilePath = "/test/filePath"

// Test if the method ProcessVulnerabilityCount groups vulnerabilities correctly
// and calls the processor function with the correct VulnerabilityCountInformation
func TestVulnerabilityCountImpl_ProcessVulnerabilityCount_CountWithinFile(t *testing.T) {
	c := testutil.UnitTest(t)
	r := testRange()
	issues := testIssues(testFilePath, r)

	vc := NewVulnerabilityCountService(c)
	testFunc := func(vci VulnerabilityCountInformation) error {
		assert.Equal(t, testFilePath, vci.FilePath)
		assert.Equal(t, r, vci.Range)
		assert.Equal(t, 4, vci.total)
		assert.Equal(t, 1, vci.severityCounts[snyk.High])
		assert.Equal(t, 3, vci.severityCounts[snyk.Medium])
		assert.Equal(t, "id1", vci.mostSevereVulnerabilityId)
		return nil
	}

	err := vc.ProcessVulnerabilityCount(issues, testFunc)

	assert.NoError(t, err)
}

func TestVulnerabilityCountImpl_ProcessVulnerabilityCount_ShouldCallProcessingFunction(t *testing.T) {
	c := testutil.UnitTest(t)
	// use a buffered channel so it could be used without waiting for a read on the channel
	processingChan := make(chan bool, 4)
	defer close(processingChan)

	calls := 1
	processingFunc := func(vci VulnerabilityCountInformation) error {
		go func() {
			assert.Equal(t, 1, calls)
			processingChan <- true
		}()
		return nil
	}

	vc := NewVulnerabilityCountService(c)
	issues := testIssues(testFilePath, testRange())

	err := vc.ProcessVulnerabilityCount(issues, processingFunc)

	assert.NoError(t, err)
	assert.Eventually(t, func() bool {
		return <-processingChan && len(processingChan) == 0
	}, 1*time.Second, time.Millisecond)
}

func TestVulnerabilityCountImpl_ProcessVulnerabilityCount_GroupByFile(t *testing.T) {
	c := testutil.UnitTest(t)
	r := snyk.Range{
		Start: snyk.Position{
			Line: 10,
		},
		End: snyk.Position{
			Line:      10,
			Character: math.MaxInt32,
		},
	}
	filePath := "/test/filePath"
	filePath2 := "/test/filePath2"
	issues := []snyk.Issue{
		{
			ID:               "id1",
			Severity:         snyk.High,
			AffectedFilePath: filePath,
			Range:            r,
		},
		{
			ID:               "id2",
			Severity:         snyk.Medium,
			AffectedFilePath: filePath2,
			Range:            r,
		},
	}

	vc := NewVulnerabilityCountService(c)
	testFunc := func(vci VulnerabilityCountInformation) error {
		if vci.FilePath == filePath {
			assert.Equal(t, 1, vci.total)
			assert.Equal(t, 1, vci.severityCounts[snyk.High])
			assert.Equal(t, "id1", vci.mostSevereVulnerabilityId)
		} else if vci.FilePath == filePath2 {
			assert.Equal(t, 1, vci.total)
			assert.Equal(t, 1, vci.severityCounts[snyk.Medium])
			assert.Equal(t, "id2", vci.mostSevereVulnerabilityId)
		} else {
			assert.Fail(t, "Unexpected file path")
		}
		return nil
	}

	err := vc.ProcessVulnerabilityCount(issues, testFunc)

	assert.NoError(t, err)
}

func TestVulnerabilityCountImpl_ProcessVulnerabilityCount_GroupByRange(t *testing.T) {
	c := testutil.UnitTest(t)
	range1 := snyk.Range{
		Start: snyk.Position{
			Line: 10,
		},
		End: snyk.Position{
			Line:      10,
			Character: math.MaxInt32,
		},
	}
	range2 := snyk.Range{
		Start: snyk.Position{
			Line: 11,
		},
		End: snyk.Position{
			Line:      11,
			Character: math.MaxInt32,
		},
	}
	filePath := "/test/filePath"
	issues := []snyk.Issue{
		{
			ID:               "id1",
			Severity:         snyk.High,
			AffectedFilePath: filePath,
			Range:            range1,
		},
		{
			ID:               "id2",
			Severity:         snyk.Medium,
			AffectedFilePath: filePath,
			Range:            range2,
		},
	}

	vc := NewVulnerabilityCountService(c)
	testFunc := func(vci VulnerabilityCountInformation) error {
		if vci.Range == range1 {
			assert.Equal(t, 1, vci.total)
			assert.Equal(t, 1, vci.severityCounts[snyk.High])
			assert.Equal(t, "id1", vci.mostSevereVulnerabilityId)
		} else if vci.Range == range2 {
			assert.Equal(t, 1, vci.total)
			assert.Equal(t, 1, vci.severityCounts[snyk.Medium])
			assert.Equal(t, "id2", vci.mostSevereVulnerabilityId)
		} else {
			assert.Fail(t, "Unexpected file path")
		}
		return nil
	}

	err := vc.ProcessVulnerabilityCount(issues, testFunc)

	assert.NoError(t, err)
}

func testIssues(filePath string, r snyk.Range) []snyk.Issue {
	return []snyk.Issue{
		{
			ID:               "id1",
			Severity:         snyk.High,
			AffectedFilePath: filePath,
			Range:            r,
		},
		{
			ID:               "id2",
			Severity:         snyk.Medium,
			AffectedFilePath: filePath,
			Range:            r,
		},
		{
			ID:               "id3",
			Severity:         snyk.Medium,
			AffectedFilePath: filePath,
			Range:            r,
		},
		{
			ID:               "id4",
			Severity:         snyk.Medium,
			AffectedFilePath: filePath,
			Range:            r,
		},
	}
}

func testRange() snyk.Range {
	return snyk.Range{
		Start: snyk.Position{
			Line: 10,
		},
		End: snyk.Position{
			Line:      10,
			Character: math.MaxInt32,
		},
	}
}
