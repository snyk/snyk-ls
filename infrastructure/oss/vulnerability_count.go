/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"fmt"
	"math"

	"github.com/snyk/snyk-ls/application/config"
	"github.com/snyk/snyk-ls/domain/snyk"
)

var (
	_ snyk.InlineValue = (*VulnerabilityCountInformation)(nil)
)

type VulnerabilityCountInformation struct {
	path                      string
	myRange                   snyk.Range
	total                     int
	severityCounts            map[snyk.Severity]int
	mostSevereVulnerabilityId string
}

func (v *VulnerabilityCountInformation) Path() string {
	return v.path
}

func (v *VulnerabilityCountInformation) Range() snyk.Range {
	return v.myRange
}

func (v *VulnerabilityCountInformation) String() string {
	return fmt.Sprintf(
		"filepath: %s, Line: %d, total: %d, mostSevereId: %s",
		v.path,
		v.myRange.Start.Line,
		v.total,
		v.mostSevereVulnerabilityId,
	)
}

type VulnerabilityCountInformationMap map[string]map[snyk.Range]*VulnerabilityCountInformation

type VulnerabilityCountService interface {
	DetermineVulnerabilityCounts(issues []snyk.Issue) (VulnerabilityCountInformationMap, error)
}

type vulnerabilityCountImpl struct {
	c *config.Config
}

func (v *vulnerabilityCountImpl) DetermineVulnerabilityCounts(issues []snyk.Issue) (VulnerabilityCountInformationMap, error) {
	logger := v.c.Logger().With().Str("method", "DetermineVulnerabilityCounts").Logger()

	// create one vulnerability count per filepath and range and group issues by severity
	// for each vulnerabilityCountInformation call the processor function
	vulnerabilityCounts := make(VulnerabilityCountInformationMap)
	var highestIssueSeverity = snyk.Low

	for _, issue := range issues {
		start := snyk.Position{Character: 0, Line: issue.Range.Start.Line}
		end := snyk.Position{Character: math.MaxInt32, Line: issue.Range.Start.Line}
		myRange := snyk.Range{Start: start, End: end}

		if vulnerabilityCounts[issue.AffectedFilePath] == nil {
			vulnerabilityCounts[issue.AffectedFilePath] = make(map[snyk.Range]*VulnerabilityCountInformation)
		}

		if vulnerabilityCounts[issue.AffectedFilePath][myRange] == nil {
			vulnerabilityCounts[issue.AffectedFilePath][myRange] = &VulnerabilityCountInformation{
				path:           issue.AffectedFilePath,
				myRange:        myRange,
				severityCounts: make(map[snyk.Severity]int),
			}
		}

		vc := vulnerabilityCounts[issue.AffectedFilePath][myRange]
		vc.total++
		vc.severityCounts[issue.Severity]++

		if highestIssueSeverity > issue.Severity || vc.mostSevereVulnerabilityId == "" {
			highestIssueSeverity = issue.Severity
			vc.mostSevereVulnerabilityId = issue.ID
		}

		logger.Debug().Str("vulnerability count", vc.String()).Msgf("updated")
	}

	logger.Debug().Int("count", len(vulnerabilityCounts)).
		Msgf("created vulnerability counts")
	return vulnerabilityCounts, nil
}

func NewVulnerabilityCountService(c *config.Config) VulnerabilityCountService {
	return &vulnerabilityCountImpl{c: c}
}

func (cliScanner *CLIScanner) addVulnerabilityCountsToCache(issues []snyk.Issue) {
	logger := cliScanner.config.Logger().With().Str("method", "addVulnerabilityCountsToCache").Logger()
	vc := NewVulnerabilityCountService(cliScanner.config)
	counts, err := vc.DetermineVulnerabilityCounts(issues)
	if err != nil {
		logger.Err(err).Msg("couldn't get vulnerability counts")
		cliScanner.errorReporter.CaptureError(err)
	}
	for _, myRange := range counts {
		for _, vulnerabilityCountInformation := range myRange {
			addToCache(vulnerabilityCountInformation, cliScanner.inlineValues)
			logger.Debug().Str("inline value", vulnerabilityCountInformation.String()).Msg("added to cache")
		}
	}
}

// removeVulnerabilityCountsFromCache removes all vulnerability counts from the cache that overlap with the given issues.
// When the first issue hits an overlapping vulnerability count, the whole vulnerability count is removed from the cache.
func (cliScanner *CLIScanner) removeVulnerabilityCountsFromCache(issues []snyk.Issue) {
	logger := cliScanner.config.Logger().With().Str("method", "removeVulnerabilityCountsFromCache").Logger()
	for _, issue := range issues {
		inlineValues := cliScanner.inlineValues[issue.AffectedFilePath]
		keptInlineValues := []snyk.InlineValue{}
		for _, inlineValue := range inlineValues {
			if vci, ok := inlineValue.(*VulnerabilityCountInformation); ok && vci.mostSevereVulnerabilityId == issue.ID {
				logger.Debug().Msgf("removed inline value %s", inlineValue.String())
			} else {
				keptInlineValues = append(keptInlineValues, inlineValue)
				logger.Debug().Msgf("kept inline value %s", inlineValue.String())
			}
		}
		cliScanner.inlineValues[issue.AffectedFilePath] = keptInlineValues
	}
}

func (v *VulnerabilityCountInformation) Text() string {
	text := ""

	if v.total > 0 {
		text += fmt.Sprintf("Vulnerabilities: %d", v.total)

		// amend text if there are Vulnerabilities
		if v.severityCounts[snyk.Critical] > 0 {
			text += fmt.Sprintf(" | Critical: %d", v.severityCounts[snyk.Critical])
		}

		if v.severityCounts[snyk.High] > 0 {
			text += fmt.Sprintf(" | High: %d", v.severityCounts[snyk.High])
		}

		if v.severityCounts[snyk.Medium] > 0 {
			text += fmt.Sprintf(" | Medium: %d", v.severityCounts[snyk.Medium])
		}

		if v.severityCounts[snyk.Low] > 0 {
			text += fmt.Sprintf(" | Low: %d", v.severityCounts[snyk.Low])
		}
	}

	return text
}
