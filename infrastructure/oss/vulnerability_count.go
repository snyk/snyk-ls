/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"fmt"
	"math"

	"github.com/rs/zerolog"

	"github.com/snyk/snyk-ls/application/config"
	"github.com/snyk/snyk-ls/domain/ide/filter"
	"github.com/snyk/snyk-ls/domain/snyk"
	"github.com/snyk/snyk-ls/internal/types"
)

var (
	_ snyk.InlineValue = (*VulnerabilityCountInformation)(nil)
)

type VulnerabilityCountInformation struct {
	path                      types.FilePath
	myRange                   types.Range
	total                     int
	hiddenCount               int
	severityCounts            map[types.Severity]int
	mostSevereVulnerabilityId string
}

func (v *VulnerabilityCountInformation) Path() types.FilePath {
	return v.path
}

func (v *VulnerabilityCountInformation) Range() types.Range {
	return v.myRange
}

func (v *VulnerabilityCountInformation) String() string {
	return fmt.Sprintf(
		"filepath: %s, Line: %d, total: %d, mostSevereId: %s",
		v.path,
		v.myRange.Start.Line,
		v.total,
		v.mostSevereVulnerabilityId,
	)
}

type VulnerabilityCountInformationMap map[types.FilePath]map[types.Range]*VulnerabilityCountInformation

type VulnerabilityCountService interface {
	DetermineVulnerabilityCounts(issues []types.Issue) (VulnerabilityCountInformationMap, error)
}

type vulnerabilityCountImpl struct {
	c *config.Config
}

func (v *vulnerabilityCountImpl) DetermineVulnerabilityCounts(issues []types.Issue) (VulnerabilityCountInformationMap, error) {
	logger := v.c.Logger().With().Str("method", "DetermineVulnerabilityCounts").Logger()

	// create one vulnerability count per filepath and range and group issues by severity
	// for each vulnerabilityCountInformation call the processor function
	vulnerabilityCounts := make(VulnerabilityCountInformationMap)
	var highestIssueSeverity = types.Low

	for _, issue := range issues {
		start := types.Position{Character: 0, Line: issue.GetRange().Start.Line}
		end := types.Position{Character: math.MaxInt32, Line: issue.GetRange().Start.Line}
		myRange := types.Range{Start: start, End: end}

		affectedFilePath := issue.GetAffectedFilePath()
		m := vulnerabilityCounts[affectedFilePath]
		if m == nil {
			m = make(map[types.Range]*VulnerabilityCountInformation)
			vulnerabilityCounts[affectedFilePath] = m
		}

		if m[myRange] == nil {
			m[myRange] = &VulnerabilityCountInformation{
				path:           affectedFilePath,
				myRange:        myRange,
				severityCounts: make(map[types.Severity]int),
			}
		}

		vc := m[myRange]
		vc.total++
		vc.severityCounts[issue.GetSeverity()]++

		if highestIssueSeverity > issue.GetSeverity() || vc.mostSevereVulnerabilityId == "" {
			highestIssueSeverity = issue.GetSeverity()
			vc.mostSevereVulnerabilityId = issue.GetID()
		}

		logger.Debug().Str("issue count", vc.String()).Msgf("updated")
	}

	logger.Debug().Int("count", len(vulnerabilityCounts)).
		Msgf("created issue counts")
	return vulnerabilityCounts, nil
}

func NewVulnerabilityCountService(c *config.Config) VulnerabilityCountService {
	return &vulnerabilityCountImpl{c: c}
}

func (cliScanner *CLIScanner) addVulnerabilityCountsToCache(issues []types.Issue) {
	logger := cliScanner.config.Logger().With().Str("method", "addVulnerabilityCountsToCache").Logger()

	// Get counts for both filtered and unfiltered issues
	filteredIssues := cliScanner.filterIssuesForCounting(issues)
	logger.Debug().Int("original", len(issues)).Int("filtered", len(filteredIssues)).Msg("filtered issues for vulnerability counts")

	vc := NewVulnerabilityCountService(cliScanner.config)

	// Get counts for filtered issues
	filteredCounts, err := vc.DetermineVulnerabilityCounts(filteredIssues)
	if err != nil {
		logger.Err(err).Msg("couldn't get issue counts")
		cliScanner.errorReporter.CaptureError(err)
	}

	// Get counts for all issues to calculate hidden per range
	allCounts, err := vc.DetermineVulnerabilityCounts(issues)
	if err != nil {
		logger.Err(err).Msg("couldn't get all issue counts")
		cliScanner.errorReporter.CaptureError(err)
	}

	// Calculate hidden count per range and add to cache
	cliScanner.addCountsWithHiddenInfo(filteredCounts, allCounts, logger)
}

// addCountsWithHiddenInfo adds filtered counts to cache with hidden count calculated per range
func (cliScanner *CLIScanner) addCountsWithHiddenInfo(filteredCounts, allCounts VulnerabilityCountInformationMap, logger zerolog.Logger) {
	// Track which ranges we've processed from filtered counts
	processedRanges := make(map[types.FilePath]map[types.Range]bool)

	// Add filtered counts with their hidden counts
	for filePath, rangeMap := range filteredCounts {
		if processedRanges[filePath] == nil {
			processedRanges[filePath] = make(map[types.Range]bool)
		}
		for r, filteredCount := range rangeMap {
			processedRanges[filePath][r] = true

			// Calculate hidden count for this specific range
			if allCountForFile, ok := allCounts[filePath]; ok {
				if allCount, ok := allCountForFile[r]; ok {
					filteredCount.hiddenCount = allCount.total - filteredCount.total
				}
			}

			cliScanner.addToCache(filteredCount, cliScanner.inlineValues)
			logger.Debug().Str("inline value", filteredCount.String()).Msg("added to cache")
		}
	}

	// Handle ranges that exist in allCounts but not in filteredCounts (all issues hidden for that range)
	for filePath, rangeMap := range allCounts {
		for r, allCount := range rangeMap {
			if processedRanges[filePath] != nil && processedRanges[filePath][r] {
				continue // Already processed
			}

			// All issues for this range are hidden
			hiddenOnlyCount := &VulnerabilityCountInformation{
				path:                      filePath,
				myRange:                   r,
				total:                     0,
				hiddenCount:               allCount.total,
				severityCounts:            make(map[types.Severity]int),
				mostSevereVulnerabilityId: "",
			}
			cliScanner.addToCache(hiddenOnlyCount, cliScanner.inlineValues)
			logger.Debug().Str("inline value", hiddenOnlyCount.String()).Msg("added hidden-only count to cache")
		}
	}
}

// filterIssuesForCounting applies severity and risk score filters to issues before counting
func (cliScanner *CLIScanner) filterIssuesForCounting(issues []types.Issue) []types.Issue {
	if len(issues) == 0 {
		return issues
	}

	// Get the folder containing the first issue's file path
	// All issues in a scan batch are from the same folder, so using the first issue is sufficient
	filePath := issues[0].GetAffectedFilePath()
	folder := cliScanner.config.Workspace().GetFolderContaining(filePath)
	if folder == nil {
		// No folder found - this shouldn't happen in normal operation
		// Return empty to avoid showing unfiltered issues that might violate user's filter settings
		return []types.Issue{}
	}

	// Use centralized filter logic
	return filter.FilterIssues(issues, cliScanner.config, folder.Path())
}

func (v *VulnerabilityCountInformation) Text() string {
	text := ""

	if v.total > 0 {
		text += fmt.Sprintf("Issues: %d", v.total)

		// amend text if there are Issues
		if v.severityCounts[types.Critical] > 0 {
			text += fmt.Sprintf(" | Critical: %d", v.severityCounts[types.Critical])
		}

		if v.severityCounts[types.High] > 0 {
			text += fmt.Sprintf(" | High: %d", v.severityCounts[types.High])
		}

		if v.severityCounts[types.Medium] > 0 {
			text += fmt.Sprintf(" | Medium: %d", v.severityCounts[types.Medium])
		}

		if v.severityCounts[types.Low] > 0 {
			text += fmt.Sprintf(" | Low: %d", v.severityCounts[types.Low])
		}

		// Add hidden count if there are hidden issues
		if v.hiddenCount > 0 {
			plural := "s"
			if v.hiddenCount == 1 {
				plural = ""
			}
			text += fmt.Sprintf(" | (Hidden: %d issue%s)", v.hiddenCount, plural)
		}
	} else if v.hiddenCount > 0 {
		// If all issues are hidden (total is 0), show only hidden count
		plural := "s"
		if v.hiddenCount == 1 {
			plural = ""
		}
		text = fmt.Sprintf("(Hidden: %d issue%s)", v.hiddenCount, plural)
	}

	return text
}
