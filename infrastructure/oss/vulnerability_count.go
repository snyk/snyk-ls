/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"fmt"
	"math"

	"github.com/snyk/snyk-ls/application/config"
	"github.com/snyk/snyk-ls/domain/snyk"
)

type VulnerabilityCountInformation struct {
	FilePath                  string
	Range                     snyk.Range
	total                     int
	severityCounts            map[snyk.Severity]int
	mostSevereVulnerabilityId string
}

func (v *VulnerabilityCountInformation) String() string {
	return fmt.Sprintf(
		"filepath: %s, Line: %d, total: %d, mostSevereId: %s",
		v.FilePath,
		v.Range.Start.Line,
		v.total,
		v.mostSevereVulnerabilityId,
	)
}

type VulnerabilityCountInformationMap map[string]map[snyk.Range]*VulnerabilityCountInformation

type VulnerabilityCountService interface {
	DetermineVulnerabilityCounts(issues []snyk.Issue) (VulnerabilityCountInformationMap, error)
}

type vulnerabilityCountImpl struct {
	c *config.Config
}

func (v *vulnerabilityCountImpl) DetermineVulnerabilityCounts(issues []snyk.Issue) (VulnerabilityCountInformationMap, error) {
	logger := v.c.Logger().With().Str("method", "DetermineVulnerabilityCounts").Logger()

	// create one vulnerability count per filepath and range and group issues by severity
	// for each vulnerabilityCountInformation call the processor function
	vulnerabilityCounts := make(VulnerabilityCountInformationMap)
	var highestIssueSeverity = snyk.Low

	for _, issue := range issues {
		start := snyk.Position{Character: 0, Line: issue.Range.Start.Line}
		end := snyk.Position{Character: math.MaxInt32, Line: issue.Range.Start.Line}
		myRange := snyk.Range{Start: start, End: end}

		if vulnerabilityCounts[issue.AffectedFilePath] == nil {
			vulnerabilityCounts[issue.AffectedFilePath] = make(map[snyk.Range]*VulnerabilityCountInformation)
		}

		if vulnerabilityCounts[issue.AffectedFilePath][myRange] == nil {
			vulnerabilityCounts[issue.AffectedFilePath][myRange] = &VulnerabilityCountInformation{
				FilePath:       issue.AffectedFilePath,
				Range:          myRange,
				severityCounts: make(map[snyk.Severity]int),
			}
		}

		vc := vulnerabilityCounts[issue.AffectedFilePath][myRange]
		vc.total++
		vc.severityCounts[issue.Severity]++

		if highestIssueSeverity > issue.Severity || vc.mostSevereVulnerabilityId == "" {
			highestIssueSeverity = issue.Severity
			vc.mostSevereVulnerabilityId = issue.ID
		}

		logger.Debug().Any("vulnerability count", vc).Msgf("updated")
	}

	logger.Debug().Int("count", len(vulnerabilityCounts)).
		Msgf("created vulnerability counts")
	return vulnerabilityCounts, nil
}

func NewVulnerabilityCountService(c *config.Config) VulnerabilityCountService {
	return &vulnerabilityCountImpl{c: c}
}

func (oss *Scanner) addVulnerabilityCountsAsInlineValuesToCache(issues []snyk.Issue) {
	c := config.CurrentConfig()
	logger := c.Logger().With().Str("method", "addVulnerabilityCountsAsInlineValuesToCache").Logger()
	vc := NewVulnerabilityCountService(c)
	counts, err := vc.DetermineVulnerabilityCounts(issues)
	if err != nil {
		logger.Err(err).Msg("couldn't get vulnerability counts")
		oss.errorReporter.CaptureError(err)
	}
	for _, myRange := range counts {
		for _, vulnerabilityCountInformation := range myRange {
			value := oss.toInlineValueAndAddToCache(vulnerabilityCountInformation)
			logger.Debug().
				Any("inline value", value).
				Msg("added to cache")
		}
	}
}

func (oss *Scanner) getDisplayTextForVulnerabilityCount(vci *VulnerabilityCountInformation) string {
	text := fmt.Sprintf(
		"Vulnerabilities: %d | Critical: %d, High: %d, Medium: %d, Low: %d | Most Severe: %s",
		vci.total,
		vci.severityCounts[snyk.Critical],
		vci.severityCounts[snyk.High],
		vci.severityCounts[snyk.Medium],
		vci.severityCounts[snyk.Low],
		vci.mostSevereVulnerabilityId,
	)
	return text
}

func (oss *Scanner) toInlineValueAndAddToCache(vci *VulnerabilityCountInformation) snyk.InlineValue {
	inlineValues := oss.inlineValues[vci.FilePath]

	if inlineValues == nil {
		inlineValues = []snyk.InlineValue{}
	}

	inlineValue := oss.toInlineValue(vci)
	inlineValues = append(inlineValues, inlineValue)

	oss.inlineValues[vci.FilePath] = inlineValues

	return inlineValue
}

func (oss *Scanner) toInlineValue(vci *VulnerabilityCountInformation) snyk.InlineValue {
	text := oss.getDisplayTextForVulnerabilityCount(vci)
	value := snyk.InlineValue{
		Path:  vci.FilePath,
		Range: vci.Range,
		Text:  text,
	}
	return value
}
