/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"fmt"
	"math"

	"github.com/snyk/snyk-ls/application/config"
	"github.com/snyk/snyk-ls/domain/snyk"
	"github.com/snyk/snyk-ls/internal/types"
)

var (
	_ snyk.InlineValue = (*VulnerabilityCountInformation)(nil)
)

type VulnerabilityCountInformation struct {
	path                      types.FilePath
	myRange                   types.Range
	total                     int
	severityCounts            map[types.Severity]int
	mostSevereVulnerabilityId string
}

func (v *VulnerabilityCountInformation) Path() types.FilePath {
	return v.path
}

func (v *VulnerabilityCountInformation) Range() types.Range {
	return v.myRange
}

func (v *VulnerabilityCountInformation) String() string {
	return fmt.Sprintf(
		"filepath: %s, Line: %d, total: %d, mostSevereId: %s",
		v.path,
		v.myRange.Start.Line,
		v.total,
		v.mostSevereVulnerabilityId,
	)
}

type VulnerabilityCountInformationMap map[types.FilePath]map[types.Range]*VulnerabilityCountInformation

type VulnerabilityCountService interface {
	DetermineVulnerabilityCounts(issues []types.Issue) (VulnerabilityCountInformationMap, error)
}

type vulnerabilityCountImpl struct {
	c *config.Config
}

func (v *vulnerabilityCountImpl) DetermineVulnerabilityCounts(issues []types.Issue) (VulnerabilityCountInformationMap, error) {
	logger := v.c.Logger().With().Str("method", "DetermineVulnerabilityCounts").Logger()

	// create one vulnerability count per filepath and range and group issues by severity
	// for each vulnerabilityCountInformation call the processor function
	vulnerabilityCounts := make(VulnerabilityCountInformationMap)
	var highestIssueSeverity = types.Low

	for _, issue := range issues {
		start := types.Position{Character: 0, Line: issue.GetRange().Start.Line}
		end := types.Position{Character: math.MaxInt32, Line: issue.GetRange().Start.Line}
		myRange := types.Range{Start: start, End: end}

		affectedFilePath := issue.GetAffectedFilePath()
		m := vulnerabilityCounts[affectedFilePath]
		if m == nil {
			m = make(map[types.Range]*VulnerabilityCountInformation)
			vulnerabilityCounts[affectedFilePath] = m
		}

		if m[myRange] == nil {
			m[myRange] = &VulnerabilityCountInformation{
				path:           affectedFilePath,
				myRange:        myRange,
				severityCounts: make(map[types.Severity]int),
			}
		}

		vc := m[myRange]
		vc.total++
		vc.severityCounts[issue.GetSeverity()]++

		if highestIssueSeverity > issue.GetSeverity() || vc.mostSevereVulnerabilityId == "" {
			highestIssueSeverity = issue.GetSeverity()
			vc.mostSevereVulnerabilityId = issue.GetID()
		}

		logger.Debug().Str("issue count", vc.String()).Msgf("updated")
	}

	logger.Debug().Int("count", len(vulnerabilityCounts)).
		Msgf("created issue counts")
	return vulnerabilityCounts, nil
}

func NewVulnerabilityCountService(c *config.Config) VulnerabilityCountService {
	return &vulnerabilityCountImpl{c: c}
}

func (cliScanner *CLIScanner) addVulnerabilityCountsToCache(issues []types.Issue) {
	logger := cliScanner.config.Logger().With().Str("method", "addVulnerabilityCountsToCache").Logger()
	vc := NewVulnerabilityCountService(cliScanner.config)
	counts, err := vc.DetermineVulnerabilityCounts(issues)
	if err != nil {
		logger.Err(err).Msg("couldn't get issue counts")
		cliScanner.errorReporter.CaptureError(err)
	}
	for _, myRange := range counts {
		for _, vulnerabilityCountInformation := range myRange {
			cliScanner.addToCache(vulnerabilityCountInformation, cliScanner.inlineValues)
			logger.Debug().Str("inline value", vulnerabilityCountInformation.String()).Msg("added to cache")
		}
	}
}

// removeVulnerabilityCountsFromCache removes all issue counts from the cache that overlap with the given issues.
// When the first issue hits an overlapping issue count, the whole issue count is removed from the cache.
func (cliScanner *CLIScanner) removeVulnerabilityCountsFromCache(issues []types.Issue) {
	logger := cliScanner.config.Logger().With().Str("method", "removeVulnerabilityCountsFromCache").Logger()
	for _, issue := range issues {
		cliScanner.inlineValueMutex.RLock()
		affectedFilePath := issue.GetAffectedFilePath()
		inlineValues := cliScanner.inlineValues[affectedFilePath]
		cliScanner.inlineValueMutex.RUnlock()

		keptInlineValues := []snyk.InlineValue{}
		for _, inlineValue := range inlineValues {
			if vci, ok := inlineValue.(*VulnerabilityCountInformation); ok && vci.mostSevereVulnerabilityId == issue.GetID() {
				logger.Debug().Msgf("removed inline value %s", inlineValue.String())
			} else {
				keptInlineValues = append(keptInlineValues, inlineValue)
				logger.Debug().Msgf("kept inline value %s", inlineValue.String())
			}
		}
		cliScanner.inlineValueMutex.Lock()
		cliScanner.inlineValues[affectedFilePath] = keptInlineValues
		cliScanner.inlineValueMutex.Unlock()
	}
}

func (v *VulnerabilityCountInformation) Text() string {
	text := ""

	if v.total > 0 {
		text += fmt.Sprintf("Issues: %d", v.total)

		// amend text if there are Issues
		if v.severityCounts[types.Critical] > 0 {
			text += fmt.Sprintf(" | Critical: %d", v.severityCounts[types.Critical])
		}

		if v.severityCounts[types.High] > 0 {
			text += fmt.Sprintf(" | High: %d", v.severityCounts[types.High])
		}

		if v.severityCounts[types.Medium] > 0 {
			text += fmt.Sprintf(" | Medium: %d", v.severityCounts[types.Medium])
		}

		if v.severityCounts[types.Low] > 0 {
			text += fmt.Sprintf(" | Low: %d", v.severityCounts[types.Low])
		}
	}

	return text
}
