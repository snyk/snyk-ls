/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oss

import (
	"math"

	"github.com/snyk/snyk-ls/application/config"
	"github.com/snyk/snyk-ls/domain/snyk"
)

type VulnerabilityCountInformation struct {
	FilePath                  string
	Range                     snyk.Range
	total                     int
	severityCounts            map[snyk.Severity]int
	mostSevereVulnerabilityId string
}

type VulnerabilityCountService interface {
	ProcessVulnerabilityCount(issues []snyk.Issue, processor func(vci VulnerabilityCountInformation) error) error
}

type vulnerabilityCountImpl struct {
	c *config.Config
}

func (v *vulnerabilityCountImpl) ProcessVulnerabilityCount(
	issues []snyk.Issue,
	processor func(vci VulnerabilityCountInformation) error,
) error {
	method := "ProcessVulnerabilityCount"

	// create one vulnerability count per filepath and range and group issues by severity
	// for each vulnerabilityCountInformation call the processor function
	vulnerabilityCounts := make(map[string]map[snyk.Range]*VulnerabilityCountInformation)
	var highestIssueSeverity = snyk.Low

	for _, issue := range issues {
		start := snyk.Position{Character: 0, Line: issue.Range.Start.Line}
		end := snyk.Position{Character: math.MaxInt32, Line: issue.Range.Start.Line}
		myRange := snyk.Range{Start: start, End: end}

		if vulnerabilityCounts[issue.AffectedFilePath] == nil {
			vulnerabilityCounts[issue.AffectedFilePath] = make(map[snyk.Range]*VulnerabilityCountInformation)
		}

		if vulnerabilityCounts[issue.AffectedFilePath][myRange] == nil {
			vulnerabilityCounts[issue.AffectedFilePath][myRange] = &VulnerabilityCountInformation{
				FilePath:       issue.AffectedFilePath,
				Range:          myRange,
				severityCounts: make(map[snyk.Severity]int),
			}
		}

		vc := vulnerabilityCounts[issue.AffectedFilePath][myRange]
		vc.total++
		vc.severityCounts[issue.Severity]++

		if highestIssueSeverity > issue.Severity || vc.mostSevereVulnerabilityId == "" {
			highestIssueSeverity = issue.Severity
			vc.mostSevereVulnerabilityId = issue.ID
		}
	}

	for _, vulnerabilityCount := range vulnerabilityCounts {
		for _, vci := range vulnerabilityCount {
			v.c.Logger().Debug().
				Str("method", method).
				Str("filePath", vci.FilePath).
				Str("range", vci.Range.String()).
				Int("total", vci.total).
				Str("mostSevereVulnerabilityId", vci.mostSevereVulnerabilityId).
				Msg("processing vulnerability count")
			err := processor(*vci)
			if err != nil {
				v.c.Logger().Err(err).Str("method", method).Msg("error processing vulnerability count")
				return err
			}
		}
	}
	return nil
}

func NewVulnerabilityCountService(c *config.Config) VulnerabilityCountService {
	return &vulnerabilityCountImpl{c: c}
}
